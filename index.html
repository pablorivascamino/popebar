<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Popelus Simulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #000;
      font-family: monospace;
    }

    #game {
      border: 8px solid #333;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
    }
  </style>
</head>

<body>
  <canvas id="game" width="240" height="160"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    canvas.style.width = '960px';
    canvas.style.height = '640px';

    // Paleta GBA
    const C = {
      bg: '#081820', floor: '#184a48', floor2: '#205850',
      bar: '#502818', bar2: '#683020', skin: '#f8c898',
      hair: '#503020', ui: '#001820', uiBorder: '#20c0d0',
      text: '#f8f8f8', highlight: '#f8d048', red: '#f83030', green: '#30d048'
    };

    const keys = {};
    const WORLD_HEIGHT = 500;
    const touch = {
      joystick: { active: false, dx: 0, dy: 0, id: null },
      button: { pressed: false, id: null },
      // Controles para la fase bonus
      bonusLeft: { pressed: false, id: null },
      bonusRight: { pressed: false, id: null }
    };
    const state = {
      scene: 0,
      px: 120, py: 400, // Jugador empieza abajo
      camY: 320, // C√°mara
      time: 1260,
      drunk: 0,
      score: 0,
      facing: 1,
      anim: 0,
      tick: 0,
      girlCount: 0,
      mustDrink: false,
      mustTalk: false,
      dialog: '',
      dTimer: 0,
      lastTalk: 0,
      inverted: false,
      color: 0,
      spacePressed: false,
      isMoving: false,
      // Barra arriba
      barY: 40,
      // Chicas en pista de baile (abajo)
      girls: Array(10).fill(0).map((_, i) => ({
        x: 30 + (i % 5) * 40,
        y: 380 + Math.floor(i / 5) * 30,
        t: 0,
        c: i,
        spriteType: i % 2 // Alterna entre 0 (girl0) y 1 (girl1)
      })),
      // Obst√°culos con cooldown
      obstacles: [
        { x: 20, y: 100, w: 16, h: 16, t: 0 },
        { x: 204, y: 100, w: 16, h: 16, t: 0 },
        { x: 60, y: 150, w: 16, h: 16, t: 0 },
        { x: 164, y: 150, w: 16, h: 16, t: 0 },
        { x: 100, y: 200, w: 16, h: 16, t: 0 },
        { x: 124, y: 200, w: 16, h: 16, t: 0 },
        { x: 40, y: 260, w: 16, h: 16, t: 0 },
        { x: 184, y: 260, w: 16, h: 16, t: 0 }
      ],
      bonus: { x: 120, target: 120, t: 0, score: 0, max: 30 }
    };

    function drawSvg(svgBase64, x, y, w, h) {
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = function () {
        ctx.clearRect(x, y, canvas.width, canvas.height);
        ctx.drawImage(img, x, y, w, h);
      };
      img.src = svgBase64;
    }

    const PC = ['#f83030', '#30d048', '#f8d048', '#30a0f8', '#d048f8', '#f89030'];

    // Touch controls
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);

    function handleTouchStart(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const rect = canvas.getBoundingClientRect();
        const x = (t.clientX - rect.left) * (240 / rect.width);
        const y = (t.clientY - rect.top) * (160 / rect.height);

        // Transiciones de pantalla para men√∫ (escena 0) y pantalla final (escena 3)
        if (state.scene === 0 || state.scene === 3) {
          handleScreenTransition();
          return;
        }

        if (state.scene === 2) {
          // Controles para la fase bonus
          // Bot√≥n izquierda
          if (x < 50 && y > 110) {
            touch.bonusLeft.pressed = true;
            touch.bonusLeft.id = t.identifier;
          }
          // Bot√≥n derecha
          if (x > 190 && y > 110) {
            touch.bonusRight.pressed = true;
            touch.bonusRight.id = t.identifier;
          }
        } else if (state.scene === 1) {
          // Controles del juego principal
          // Joystick (derecha)
          if (x > 190 && y > 110) {
            touch.joystick.active = true;
            touch.joystick.id = t.identifier;
          }
          // Bot√≥n acci√≥n (izquierda)
          if (x < 50 && y > 110) {
            touch.button.pressed = true;
            touch.button.id = t.identifier;
            state.spacePressed = true;
          }
        }
      }
    }

    function handleTouchMove(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (touch.joystick.active && t.identifier === touch.joystick.id) {
          const rect = canvas.getBoundingClientRect();
          const x = (t.clientX - rect.left) * (240 / rect.width);
          const y = (t.clientY - rect.top) * (160 / rect.height);
          const dx = x - 215;
          const dy = y - 135;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const maxDist = 15;
          if (dist > maxDist) {
            touch.joystick.dx = (dx / dist) * maxDist;
            touch.joystick.dy = (dy / dist) * maxDist;
          } else {
            touch.joystick.dx = dx;
            touch.joystick.dy = dy;
          }
        }
      }
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];

        // Controles del juego principal
        if (t.identifier === touch.joystick.id) {
          touch.joystick.active = false;
          touch.joystick.dx = 0;
          touch.joystick.dy = 0;
          touch.joystick.id = null;
        }
        if (t.identifier === touch.button.id) {
          touch.button.pressed = false;
          touch.button.id = null;
          state.spacePressed = false;
        }

        // Controles de la fase bonus
        if (t.identifier === touch.bonusLeft.id) {
          touch.bonusLeft.pressed = false;
          touch.bonusLeft.id = null;
        }
        if (t.identifier === touch.bonusRight.id) {
          touch.bonusRight.pressed = false;
          touch.bonusRight.id = null;
        }
      }
    }

    function handleMouseDown(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (240 / rect.width);
      const y = (e.clientY - rect.top) * (160 / rect.height);

      // Transiciones de pantalla para men√∫ (escena 0) y pantalla final (escena 3)
      if (state.scene === 0 || state.scene === 3) {
        handleScreenTransition();
        return;
      }

      if (state.scene === 2) {
        // Controles para la fase bonus
        if (x < 50 && y > 110) {
          touch.bonusLeft.pressed = true;
          touch.bonusLeft.id = 'mouse-left';
        }
        if (x > 190 && y > 110) {
          touch.bonusRight.pressed = true;
          touch.bonusRight.id = 'mouse-right';
        }
      } else if (state.scene === 1) {
        // Controles del juego principal
        if (x > 190 && y > 110) {
          touch.joystick.active = true;
          touch.joystick.id = 'mouse';
        }
        if (x < 50 && y > 110) {
          touch.button.pressed = true;
          state.spacePressed = true;
        }
      }
    }

    function handleMouseMove(e) {
      if (touch.joystick.active && touch.joystick.id === 'mouse') {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (240 / rect.width);
        const y = (e.clientY - rect.top) * (160 / rect.height);
        const dx = x - 215;
        const dy = y - 135;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const maxDist = 15;
        if (dist > maxDist) {
          touch.joystick.dx = (dx / dist) * maxDist;
          touch.joystick.dy = (dy / dist) * maxDist;
        } else {
          touch.joystick.dx = dx;
          touch.joystick.dy = dy;
        }
      }
    }

    function handleMouseUp(e) {
      // Controles del juego principal
      if (touch.joystick.id === 'mouse') {
        touch.joystick.active = false;
        touch.joystick.dx = 0;
        touch.joystick.dy = 0;
        touch.joystick.id = null;
      }
      if (touch.button.pressed) {
        touch.button.pressed = false;
        state.spacePressed = false;
      }

      // Controles de la fase bonus
      if (touch.bonusLeft.id === 'mouse-left') {
        touch.bonusLeft.pressed = false;
        touch.bonusLeft.id = null;
      }
      if (touch.bonusRight.id === 'mouse-right') {
        touch.bonusRight.pressed = false;
        touch.bonusRight.id = null;
      }
    }

    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (state.scene === 0) {
        if (e.key === 'Enter' || e.key === ' ') {
          handleScreenTransition();
        }
        //if (e.key === 'ArrowLeft') state.color = (state.color + 5) % 6;
        //if (e.key === 'ArrowRight') state.color = (state.color + 1) % 6;
      }
      if (state.scene === 3 && (e.key === 'Enter' || e.key === ' ')) {
        handleScreenTransition();
      }
      if (e.key === ' ' && (state.scene === 1 || state.scene === 2)) {
        state.spacePressed = true;
      }
    });

    document.addEventListener('keyup', e => {
      keys[e.key] = false;
      if (e.key === ' ') state.spacePressed = false;
    });

    // Funci√≥n auxiliar para manejar transiciones de pantalla
    function handleScreenTransition() {
      if (state.scene === 0) {
        // Transici√≥n del men√∫ al juego
        state.scene = 1;
        state.px = 120;
        state.py = 400;
        state.camY = 320;
      } else if (state.scene === 3) {
        // Transici√≥n de la pantalla final al men√∫
        state.scene = 0;
        state.score = 0;
        state.bonus.score = 0;
        state.bonus.t = 0;
        state.drunk = 0;
        state.girlCount = 0;
        state.time = 1260;
        state.px = 120;
        state.py = 400;
        state.camY = 320;
        state.mustDrink = false;
        state.mustTalk = false;
        state.isMoving = false;
        state.dialog = '';
        state.dTimer = 0;
        state.girls.forEach(g => g.t = 0);
        state.obstacles.forEach(obs => obs.t = 0);
        state.barmaidTimer = 0;
      }
    }

    function draw() {
      if (state.scene === 0) drawMenu();
      else if (state.scene === 1) drawGame();
      else if (state.scene === 2) drawBonus();
      else if (state.scene === 3) drawEnd();
    }

    function drawMenu() {
      ctx.fillStyle = C.bg;
      ctx.fillRect(0, 0, 240, 160);

      ctx.fillStyle = C.highlight;
      ctx.font = '16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('POPELUS SIMULATOR', 120, 30);

      drawSprite(120, 70, state.color, 1, 0, 1);

      ctx.fillStyle = C.text;
      ctx.font = '6px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('Bebe para gustar', 10, 100);
      ctx.fillText('3 chicas -> barra', 10, 110);
      ctx.fillText('Beber -> hablar', 10, 120);
      ctx.fillText('Mareado invierte', 10, 130);

      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) {
        ctx.fillStyle = C.highlight;
        ctx.textAlign = 'center';
        ctx.fillText('PRESS START', 120, 150);
      }
    }

    function drawGame() {
      state.tick++;

      // Fondo
      ctx.fillStyle = C.floor;
      ctx.fillRect(0, 0, 240, 160);

      // Offset de c√°mara
      const offsetY = 80 - state.camY;

      ctx.save();
      ctx.translate(0, offsetY);

      // Piso con patr√≥n
      for (let y = 0; y < WORLD_HEIGHT; y += 16) {
        for (let x = 0; x < 240; x += 16) {
          if ((x + y) % 32 === 0) {
            ctx.fillStyle = C.floor2;
            ctx.fillRect(x, y, 16, 16);
          }
        }
      }

      // Barra (arriba)
      ctx.fillStyle = C.bar;
      ctx.fillRect(40, state.barY - 10, 160, 20);
      ctx.fillStyle = C.bar2;
      ctx.fillRect(40, state.barY - 10, 160, 4);
      drawGirl(120, state.barY - 20, state.barmaidTimer, Math.floor(state.tick / 15) % 2, 0);

      // Obst√°culos (ralentizan)
      const obstacles = [
        { x: 20, y: 100, w: 16, h: 16 },
        { x: 204, y: 100, w: 16, h: 16 },
        { x: 60, y: 150, w: 16, h: 16 },
        { x: 164, y: 150, w: 16, h: 16 },
        { x: 100, y: 200, w: 16, h: 16 },
        { x: 124, y: 200, w: 16, h: 16 },
        { x: 40, y: 260, w: 16, h: 16 },
        { x: 184, y: 260, w: 16, h: 16 }
      ];

      // Obst√°culos (bumpers con cooldown)
      const nowTime = Date.now() / 1000;
      state.obstacles.forEach(obs => {
        const canBump = nowTime - obs.t > 20;

        if (!canBump) {
          // Obst√°culo en cooldown: transparencia y tiempo restante
          ctx.globalAlpha = 0.5;
          ctx.fillStyle = C.bar;
          ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
          ctx.globalAlpha = 1;

          // Mostrar tiempo restante
          ctx.fillStyle = C.red;
          ctx.font = '6px monospace';
          ctx.textAlign = 'center';
          const left = Math.ceil(20 - (nowTime - obs.t));
          ctx.fillText(left, obs.x + obs.w / 2, obs.y - 2);
        } else {
          // Obst√°culo disponible: color normal
          ctx.fillStyle = C.bar;
          ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
        }
      });

      // Pista de baile (abajo)
      ctx.fillStyle = C.green;
      ctx.globalAlpha = 0.3;
      ctx.fillRect(10, 360, 220, 120);
      ctx.globalAlpha = 1;

      // Chicas
      const now = Date.now() / 1000;
      state.girls.forEach(g => {
        const canTalk = now - g.t > 30;
        if (!canTalk) {
          ctx.globalAlpha = 0.5;
          drawGirl(g.x, g.y, g.c, Math.floor(state.tick / 15) % 2, g.spriteType);
          ctx.globalAlpha = 1;
          ctx.fillStyle = C.red;
          ctx.font = '6px monospace';
          ctx.textAlign = 'center';
          const left = Math.ceil(30 - (now - g.t));
          ctx.fillText(left, g.x, g.y - 10);
        } else {
          drawGirl(g.x, g.y, g.c, Math.floor(state.tick / 15) % 2, g.spriteType);
        }
      });

      // Jugador
      const pc = state.inverted ? darken(PC[state.color]) : PC[state.color];
      drawSprite(state.px, state.py, state.color, state.facing, Math.floor(state.tick / 10) % 2, 1);

      ctx.restore();

      // HUD (fijo)
      ctx.fillStyle = C.ui;
      ctx.fillRect(0, 0, 240, 20);
      ctx.strokeStyle = C.uiBorder;
      ctx.strokeRect(0, 0, 240, 20);

      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      ctx.textAlign = 'left';
      const h = Math.floor(state.time / 60);
      const m = Math.floor(state.time % 60);
      // Icono reloj
      ctx.fillText('‚è∞', 5, 10);
      ctx.fillText(`${h}:${m < 10 ? '0' : ''}${m}`, 15, 10);

      // Icono cerveza
      ctx.fillText('üç∫', 40, 10);
      ctx.fillRect(50, 7, 60, 6);
      ctx.fillStyle = C.red;
      ctx.fillRect(51, 8, Math.min(58, state.drunk * 5.8), 4);

      ctx.fillStyle = C.text;
      ctx.fillText(`${state.score}`, 180, 10);

      // Joystick (esquina inferior derecha)
      ctx.fillStyle = 'rgba(32, 192, 208, 0.3)';
      ctx.beginPath();
      ctx.arc(215, 135, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.uiBorder;
      ctx.lineWidth = 2;
      ctx.stroke();

      if (touch.joystick.active) {
        ctx.fillStyle = C.uiBorder;
        ctx.beginPath();
        ctx.arc(215 + touch.joystick.dx, 135 + touch.joystick.dy, 8, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = 'rgba(32, 192, 208, 0.6)';
        ctx.beginPath();
        ctx.arc(215, 135, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Bot√≥n de acci√≥n (esquina inferior izquierda)
      ctx.fillStyle = touch.button.pressed ? 'rgba(248, 208, 72, 0.8)' : 'rgba(248, 208, 72, 0.4)';
      ctx.beginPath();
      ctx.arc(25, 135, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.highlight;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = C.text;
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('A', 25, 140);

      // Di√°logo
      if (state.dTimer > 0) {
        ctx.fillStyle = C.ui;
        ctx.fillRect(10, 120, 220, 35);
        ctx.strokeStyle = C.uiBorder;
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 120, 220, 35);
        ctx.fillStyle = C.text;
        ctx.font = '6px monospace';
        ctx.textAlign = 'left';
        wrapText(state.dialog, 15, 128, 210);
      } else {
        let msg = '';
        if (state.mustDrink) msg = 'Ve a la barra!';
        else if (state.mustTalk) msg = 'Habla con chicas!';
        else msg = 'Habla o ve a la barra';

        ctx.fillStyle = C.ui;
        ctx.fillRect(60, 145, 120, 12);
        ctx.strokeStyle = C.uiBorder;
        ctx.strokeRect(60, 145, 120, 12);
        ctx.fillStyle = C.highlight;
        ctx.font = '8px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(msg, 120, 153);
      }
    }

    function drawBonus() {
      ctx.fillStyle = C.bg;
      ctx.drawImage(spriteImages.portal, 0, 0, 240, 160);

      ctx.fillStyle = C.highlight;
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('FASE BONUS!', 120, 30);

      drawSprite(95, 105, state.color, 0, Math.floor(state.tick / 10) % 2, 2);

      ctx.fillStyle = C.floor;
      ctx.fillRect(20, 40, 200, 16);
      ctx.strokeStyle = C.uiBorder;
      ctx.strokeRect(20, 40, 200, 16);

      ctx.fillStyle = C.green;
      ctx.fillRect(state.bonus.target - 10, 41, 20, 14);

      ctx.fillStyle = PC[state.color];
      ctx.fillRect(state.bonus.x - 2, 38, 4, 20);

      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      const tLeft = Math.max(0, state.bonus.max - state.bonus.t);
      ctx.fillText(`Mant√©n el equilibrio!`, 120, 70);
      ctx.fillText(`Puntos: ${state.score}`, 60, 135);
      ctx.fillStyle = C.green;
      ctx.fillText(`Bonus: +${state.bonus.score}`, 180, 135);
      ctx.fillStyle = C.highlight;
      ctx.font = '12px monospace';
      ctx.fillText(`${state.score + state.bonus.score}`, 120, 150);

      // Botones t√°ctiles para la fase bonus
      // Bot√≥n izquierda (misma posici√≥n que bot√≥n de acci√≥n en el juego)
      ctx.fillStyle = touch.bonusLeft.pressed ? 'rgba(248, 208, 72, 0.8)' : 'rgba(248, 208, 72, 0.4)';
      ctx.beginPath();
      ctx.arc(25, 135, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.highlight;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = C.text;
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('‚Üê', 25, 140);

      // Bot√≥n derecha (lado derecho, similar al joystick pero m√°s a la izquierda)
      ctx.fillStyle = touch.bonusRight.pressed ? 'rgba(248, 208, 72, 0.8)' : 'rgba(248, 208, 72, 0.4)';
      ctx.beginPath();
      ctx.arc(215, 135, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.highlight;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = C.text;
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('‚Üí', 215, 140);
    }

    function drawEnd() {
      ctx.fillStyle = C.bg;
      ctx.fillRect(0, 0, 240, 160);

      ctx.fillStyle = C.highlight;
      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('FIN', 120, 30);

      ctx.fillStyle = C.ui;
      ctx.fillRect(40, 50, 160, 60);
      ctx.strokeStyle = C.uiBorder;
      ctx.strokeRect(40, 50, 160, 60);

      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      ctx.fillText(`Puntuaci√≥n: ${state.score}`, 120, 70);
      ctx.fillStyle = C.green;
      ctx.fillText(`Bonus: ${state.bonus.score}`, 120, 85);
      ctx.fillStyle = C.highlight;
      ctx.font = '16px monospace';
      ctx.fillText(`${state.score + state.bonus.score}`, 120, 105);

      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) {
        ctx.fillStyle = C.text;
        ctx.font = '8px monospace';
        ctx.fillText('PRESS START', 120, 145);
      }
    }

    // Cargar im√°genes de sprites
    const spriteImages = {};
    function loadSpriteImages() {
      // Sprites para caminar hacia los lados
      spriteImages.side0 = new Image();
      spriteImages.side0.src = 'assets/character-side-0.png';

      spriteImages.side1 = new Image();
      spriteImages.side1.src = 'assets/character-side-1.png';

      // Sprites para caminar hacia arriba
      spriteImages.walking0 = new Image();
      spriteImages.walking0.src = 'assets/character-walking-0.png';

      spriteImages.walking1 = new Image();
      spriteImages.walking1.src = 'assets/character-walking-1.png';

      // Sprites para caminar hacia abajo
      spriteImages.back0 = new Image();
      spriteImages.back0.src = 'assets/character-back-0.png';

      spriteImages.back1 = new Image();
      spriteImages.back1.src = 'assets/character-back-1.png';

      // Sprites para las chicas
      spriteImages.girl0_0 = new Image();
      spriteImages.girl0_0.src = 'assets/girl0-0.png';

      spriteImages.girl0_1 = new Image();
      spriteImages.girl0_1.src = 'assets/girl0-1.png';

      spriteImages.girl1_0 = new Image();
      spriteImages.girl1_0.src = 'assets/girl1-0.png';

      spriteImages.girl1_1 = new Image();
      spriteImages.girl1_1.src = 'assets/girl1-1.png';

      spriteImages.portal = new Image();
      spriteImages.portal.src = 'assets/portal.png';

    }
    // Llamar a la funci√≥n de carga cuando se inicie el script
    loadSpriteImages();

    function drawSprite(x, y, color, dir, frame, scale) {
      let img;

      // Solo animar si el jugador se est√° moviendo
      const animFrame = state.isMoving ? frame : 0;

      // Aplicar transparencia si los controles est√°n invertidos
      if (state.inverted) {
        ctx.globalAlpha = 0.5;
      } else {
        ctx.globalAlpha = 1;
      }

      // Seleccionar sprite seg√∫n la direcci√≥n
      if (dir === 2 || dir === 3) {
        // Movimiento lateral (izquierda/derecha) - usar sprites side
        img = animFrame === 0 ? spriteImages.side0 : spriteImages.side1;
      } else if ((dir === 1 && !state.inverted) || (dir === 0 && state.inverted)) {
        // Movimiento vertical (arriba/abajo) - usar sprites walking
        img = animFrame === 0 ? spriteImages.walking0 : spriteImages.walking1;
      } else {
        img = animFrame === 0 ? spriteImages.back0 : spriteImages.back1;
      }

      // Verificar que la imagen est√© cargada
      if (img && img.complete && img.naturalHeight !== 0) {
        ctx.save();

        // Voltear horizontalmente si va hacia la izquierda
        if ((dir !== 2 && !state.inverted) || (dir === 2 && state.inverted)) {
          ctx.scale(-1, 1);
          ctx.drawImage(img, -x - 8, y - 8, 16 * scale, 16 * scale);
        } else {
          ctx.drawImage(img, x - 8, y - 8, 16 * scale, 16 * scale);
        }

        ctx.restore();
      }

      // Restaurar transparencia normal
      ctx.globalAlpha = 1;
    }

    function drawGirl(x, y, idx, frame, spriteType) {
      let img;

      // Seleccionar el sprite seg√∫n el tipo y frame
      if (spriteType === 0) {
        img = frame === 0 ? spriteImages.girl0_0 : spriteImages.girl0_1;
      } else {
        img = frame === 0 ? spriteImages.girl1_0 : spriteImages.girl1_1;
      }

      // Verificar que la imagen est√© cargada
      if (img && img.complete && img.naturalHeight !== 0) {
        // Dibujar la imagen centrada en las coordenadas x, y
        const width = 16; // Ancho del sprite
        const height = 16; // Alto del sprite
        ctx.drawImage(img, x - width / 2, y - height / 2, width, height);
      }
    }

    function darken(hex) {
      const r = Math.max(0, parseInt(hex.slice(1, 3), 16) - 40);
      const g = Math.max(0, parseInt(hex.slice(3, 5), 16) - 40);
      const b = Math.max(0, parseInt(hex.slice(5, 7), 16) - 40);
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function wrapText(text, x, y, maxW) {
      const words = text.split(' ');
      let line = '';
      let py = y;
      for (const word of words) {
        const test = line + word + ' ';
        if (ctx.measureText(test).width > maxW && line) {
          ctx.fillText(line, x, py);
          line = word + ' ';
          py += 8;
        } else {
          line = test;
        }
      }
      ctx.fillText(line, x, py);
    }

    function update(dt) {
      if (state.scene === 1) updateGame(dt);
      else if (state.scene === 2) updateBonus(dt);
    }

    function updateGame(dt) {
      state.time += dt * 3;
      if (state.time >= 1440) state.time %= 1440;
      if (state.time >= 360 && state.time < 720) {
        state.scene = 2;
        state.inverted = false;
        state.bonus.max = Math.min(30, state.score / 100);
        state.bonus.t = 0;
        state.bonus.score = 0;
        return;
      }

      // Inversi√≥n
      if (state.drunk >= 8) {
        state.inverted = Math.floor(Date.now() / 5000) % 2 === 0;
      } else if (state.drunk >= 5) {
        state.inverted = true;
      } else {
        state.inverted = false;
      }

      // Movimiento
      let dx = 0, dy = 0;

      // Teclado
      if (keys.ArrowUp) { dy = -2; state.facing = 0; }
      if (keys.ArrowDown) { dy = 2; state.facing = 1; }
      if (keys.ArrowLeft) { dx = -2; state.facing = 2; }
      if (keys.ArrowRight) { dx = 2; state.facing = 3; }

      // Joystick t√°ctil
      if (touch.joystick.active) {
        dx += touch.joystick.dx * 0.15;
        dy += touch.joystick.dy * 0.15;

        // Determinar direcci√≥n seg√∫n joystick
        if (Math.abs(touch.joystick.dx) > Math.abs(touch.joystick.dy)) {
          state.facing = touch.joystick.dx > 0 ? 3 : 2;
        } else if (Math.abs(touch.joystick.dy) > 0) {
          state.facing = touch.joystick.dy > 0 ? 1 : 0;
        }
      }

      if (state.inverted) { dx = -dx; dy = -dy; }

      // Detectar si el jugador se est√° moviendo
      state.isMoving = Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1;

      if (state.drunk > 0) {
        dx += (Math.random() - 0.5) * state.drunk * 1;
      }

      // Verificar colisi√≥n con obst√°culos (efecto bumper)
      const obstacles = state.obstacles;

      // Verificar colisi√≥n individual con cada obst√°culo
      const now = Date.now() / 1000;
      let onCooldownObstacle = false;

      obstacles.forEach(obs => {
        // Verificar si el obst√°culo est√° en cooldown
        const canBump = now - obs.t > 20;

        // Calcular posici√≥n del jugador despu√©s del movimiento
        const newPx = state.px + dx;
        const newPy = state.py + dy;

        // Verificar si hay colisi√≥n
        if (newPx + 4 > obs.x && newPx - 4 < obs.x + obs.w &&
          newPy + 8 > obs.y && newPy - 8 < obs.y + obs.h) {

          if (canBump) {
            // Obst√°culo disponible: efecto bumper
            // Activar cooldown del obst√°culo
            obs.t = now;

            // Calcular el centro del obst√°culo
            const obsCenterX = obs.x + obs.w / 2;
            const obsCenterY = obs.y + obs.h / 2;

            // Calcular la direcci√≥n del empuje (desde el centro del obst√°culo hacia el jugador)
            const pushX = state.px - obsCenterX;
            const pushY = state.py - obsCenterY;

            // Normalizar la direcci√≥n y aplicar fuerza de rebote
            const distance = Math.sqrt(pushX * pushX + pushY * pushY);
            if (distance > 0) {
              const bumperForce = 36; // Fuerza del empuje aumentada
              dx += (pushX / distance) * bumperForce;
              dy += (pushY / distance) * bumperForce;
            }
          } else {
            // Obst√°culo en cooldown: ralentizar 75%
            onCooldownObstacle = true;
          }
        }
      });

      // Aplicar ralentizaci√≥n si est√° pasando por obst√°culo en cooldown
      if (onCooldownObstacle) {
        dx *= 0.25; // Reducir velocidad al 25% (ralentizaci√≥n del 75%)
        dy *= 0.25;
      }

      state.px = Math.max(10, Math.min(230, state.px + dx));
      state.py = Math.max(20, Math.min(WORLD_HEIGHT - 10, state.py + dy));

      // C√°mara sigue al jugador
      state.camY = state.py;

      // Interacci√≥n barra
      const distBar = Math.sqrt((state.px - 120) ** 2 + (state.py - state.barY) ** 2);
      if (distBar < 15 && state.spacePressed && !state.mustTalk) {
        drink();
        state.spacePressed = false;
      }

      // Interacci√≥n chicas
      if (!state.mustDrink) {
        const now = Date.now() / 1000;
        if (now - state.lastTalk > 1) {
          state.girls.forEach(g => {
            const d = Math.sqrt((state.px - g.x) ** 2 + (state.py - g.y) ** 2);
            const canTalk = now - g.t > 30;
            if (d < 15 && state.spacePressed && canTalk) {
              talkGirl(g, now);
              state.lastTalk = now;
              state.spacePressed = false;
            }
          });
        }
      }

      if (state.dTimer > 0) state.dTimer -= dt;
    }

    function drink() {
      state.drunk++;
      state.girlCount = 0;
      state.mustDrink = false;
      state.mustTalk = true;
      const msgs = state.drunk < 7 ?
        ['Aqu√≠ tienes tu licorca, gracias.', 'Una cerveza marchando. Son 2,5‚Ç¨', 'Una guiness? Claro, sin problema. Efectivo o tarjeta?'] :
        ['Eres divertido!', 'Me encantas!', 'Que carisma!'];
      state.dialog = msgs[Math.floor(Math.random() * msgs.length)];
      state.dTimer = 2; // Cambiado de 999 a 2
    }

    function talkGirl(girl, now) {
      girl.t = now;
      state.girlCount++;

      const msgs = state.drunk < 7 ?
        ['Dejame en paz', 'No me interesas', 'Vete'] :
        ['Qu√© divertido eres! Te puedo pintar un coraz√≥n en la frente?', 'Qu√© chico tan interesante! Se nota que te preocupas por las mujeres, eres un encanto!', 'Vamos a bailar juntos! Eres genial!'];
      state.dialog = msgs[Math.floor(Math.random() * msgs.length)];
      state.dTimer = 2;

      state.score += Math.floor(50 * (1 + state.drunk * 0.5));

      if (state.girlCount >= 3) {
        state.mustDrink = true;
        state.mustTalk = false;
      } else {
        state.mustTalk = false;
      }
    }

    function updateBonus(dt) {
      state.tick++;
      state.isMoving = true;
      state.bonus.t += dt;

      if (state.bonus.t >= state.bonus.max) {
        state.scene = 3;
        return;
      }

      const speed = 1 + Math.sin(state.bonus.t * 0.8) * 0.5;
      state.bonus.target += Math.sin(state.bonus.t * 2.5) * 2 * speed;
      state.bonus.target = Math.max(30, Math.min(210, state.bonus.target));

      // Controles de teclado
      if (keys.ArrowLeft) state.bonus.x -= 3;
      if (keys.ArrowRight) state.bonus.x += 3;

      // Controles t√°ctiles
      if (touch.bonusLeft.pressed) state.bonus.x -= 3;
      if (touch.bonusRight.pressed) state.bonus.x += 3;

      state.bonus.x = Math.max(22, Math.min(218, state.bonus.x));

      if (Math.abs(state.bonus.x - state.bonus.target) < 12) {
        state.bonus.score += Math.round(100 * dt);
      }
    }

    let last = 0;
    function loop(t) {
      const dt = Math.min((t - last) / 1000, 0.1);
      last = t;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>

</html>